# app.py
import os
import datetime
import json
from flask import Flask, jsonify, request
from flask_cors import CORS
from werkzeug.security import check_password_hash, generate_password_hash
from sqlalchemy import or_
from database import Session, User, Notice, Schedule, Attendance

app = Flask(__name__)
CORS(app) 

# --- AUTHENTICATION & USER ROUTES ---
@app.route('/api/login', methods=['POST'])
def login():
    data = request.json
    db_session = Session()
    user = db_session.query(User).filter_by(email=data.get('email')).first()
    db_session.close()
    if user and check_password_hash(user.password_hash, data.get('password')):
        return jsonify(user.to_dict())
    return jsonify({'error': 'Invalid credentials'}), 401

@app.route('/api/signup', methods=['POST'])
def signup():
    data = request.json
    db_session = Session()
    if db_session.query(User).filter_by(email=data.get('email')).first():
        return jsonify({'error': 'Email already exists'}), 409
    
    new_user = User(
        name=data.get('name'),
        email=data.get('email'),
        password_hash=generate_password_hash(data.get('password')),
        department=data.get('department'),
        year=int(data.get('year')),
        role='student',
        embeddings=json.dumps(data.get('embeddings', [])) # Assume embeddings are sent on signup
    )
    db_session.add(new_user)
    db_session.commit()
    user_dict = new_user.to_dict()
    db_session.close()
    return jsonify(user_dict), 201

# --- ADMIN ROUTES ---
@app.route('/api/admin/users/<int:admin_id>')
def get_users_for_admin(admin_id):
    db_session = Session()
    admin = db_session.query(User).filter_by(id=admin_id, role='admin').first()
    if not admin:
        return jsonify({'error': 'Admin not found or invalid privileges'}), 404
    users = db_session.query(User).filter(User.department == admin.department, User.id != admin.id).all()
    db_session.close()
    return jsonify([u.to_dict() for u in users])

@app.route('/api/admin/toggle_cr/<int:user_id>', methods=['POST'])
def toggle_cr_status(user_id):
    db_session = Session()
    user = db_session.query(User).get(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    user.role = 'cr' if user.role == 'student' else 'student'
    db_session.commit()
    db_session.close()
    return jsonify({'success': True, 'new_role': user.role})

# --- NOTICE ROUTES ---
@app.route('/api/notices/<int:user_id>')
def get_notices(user_id):
    db_session = Session()
    user = db_session.query(User).get(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    notices = db_session.query(Notice).filter(
        Notice.department == user.department,
        or_(Notice.year == None, Notice.year == user.year)
    ).order_by(Notice.timestamp.desc()).all()
    db_session.close()
    return jsonify([n.to_dict() for n in notices])

@app.route('/api/notices', methods=['POST'])
def send_notice():
    data = request.json
    db_session = Session()
    author = db_session.query(User).get(data.get('author_id'))
    if not author or author.role not in ['admin', 'cr']:
        return jsonify({'error': 'Unauthorized'}), 403
    
    new_notice = Notice(
        department=author.department,
        year=author.year if author.role == 'cr' else None,
        message=data.get('message'),
        author_id=author.id
    )
    db_session.add(new_notice)
    db_session.commit()
    notice_dict = new_notice.to_dict()
    db_session.close()
    return jsonify(notice_dict), 201

# --- SCHEDULE ROUTES ---
@app.route('/api/schedules/<int:user_id>')
def get_schedules(user_id):
    db_session = Session()
    user = db_session.query(User).get(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    schedules = db_session.query(Schedule).filter_by(department=user.department, year=user.year).all()
    db_session.close()
    return jsonify([s.to_dict() for s in schedules])

@app.route('/api/schedules', methods=['POST'])
def add_schedule():
    data = request.json
    db_session = Session()
    author = db_session.query(User).get(data.get('author_id'))
    if not author or author.role != 'cr':
        return jsonify({'error': 'Unauthorized'}), 403
        
    new_schedule = Schedule(
        department=author.department, year=author.year,
        subject_name=data.get('subject'), day_of_week=data.get('dayOfWeek'),
        start_time=data.get('startTime'), end_time=data.get('endTime'),
        cr_author_id=author.id
    )
    db_session.add(new_schedule)
    db_session.commit()
    schedule_dict = new_schedule.to_dict()
    db_session.close()
    return jsonify(schedule_dict), 201

# --- ATTENDANCE VIEW ROUTE ---
@app.route('/api/attendance/<int:user_id>')
def get_attendance(user_id):
    db_session = Session()
    user = db_session.query(User).get(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    attendance_records = db_session.query(Attendance).filter_by(user_id=user_id).all()
    db_session.close()
    return jsonify([rec.to_dict() for rec in attendance_records])

# --- CORRECTED: ADDED MISSING SYNC ENDPOINTS ---
@app.route('/api/sync/attendance', methods=['POST'])
def sync_attendance():
    data = request.json
    records = data.get('records', [])
    if not records:
        return jsonify({'error': 'No records to sync'}), 400

    db_session = Session()
    try:
        for rec in records:
            # The client should prevent duplicates, but we can double-check here if needed
            new_attendance = Attendance(
                user_id=rec['user_id'],
                schedule_id=rec['schedule_id'],
                timestamp=datetime.datetime.fromisoformat(rec['timestamp'])
            )
            db_session.add(new_attendance)
        db_session.commit()
    except Exception as e:
        db_session.rollback()
        return jsonify({'error': f'Failed to sync attendance: {e}'}), 500
    finally:
        db_session.close()
        
    return jsonify({'success': True, 'synced_records': len(records)}), 200

@app.route('/api/sync/get_updates', methods=['GET'])
def get_updates():
    last_sync_time_str = request.args.get('last_sync_time')
    
    # Parse last sync time, or use a very old date if it's the first sync
    if last_sync_time_str:
        last_sync_time = datetime.datetime.fromisoformat(last_sync_time_str)
    else:
        last_sync_time = datetime.datetime(1970, 1, 1)

    db_session = Session()
    
    # Find all users and schedules updated since the last sync
    updated_users = db_session.query(User).filter(User.updated_at > last_sync_time).all()
    updated_schedules = db_session.query(Schedule).filter(Schedule.updated_at > last_sync_time).all()
    
    updates = {
        'users': [user.to_dict() for user in updated_users],
        'schedules': [schedule.to_dict() for schedule in updated_schedules]
    }
    
    db_session.close()
    
    return jsonify({
        'updates': updates,
        'server_time': datetime.datetime.utcnow().isoformat()
    })

if __name__ == '__main__':
    if not os.path.exists('main_database.db'):
        from database import create_db
        create_db()
    app.run(host='0.0.0.0', port=5000, debug=True)

# database.py
import os
import datetime
import json
from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship, declarative_base
from werkzeug.security import generate_password_hash

db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'main_database.db')
engine = create_engine(f'sqlite:///{db_path}')
Session = sessionmaker(bind=engine)
Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password_hash = Column(String(128), nullable=False)
    role = Column(String(10), nullable=False, default='student')
    department = Column(String(50), nullable=False)
    year = Column(Integer) # Represents admission year
    embeddings = Column(Text, nullable=True) 
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships with cascading deletes
    notices = relationship("Notice", back_populates="author", cascade="all, delete", passive_deletes=True)
    attendance_records = relationship("Attendance", back_populates="user", cascade="all, delete", passive_deletes=True)

    def to_dict(self):
        return {
            'id': self.id, 
            'name': self.name, 
            'email': self.email,
            'role': self.role, 
            'department': self.department, 
            'year': self.year,
            'avatarUrl': f'https://i.pravatar.cc/150?u={self.id}',
            'embeddings': json.loads(self.embeddings) if self.embeddings else []
        }

class Schedule(Base):
    __tablename__ = 'schedules'
    id = Column(Integer, primary_key=True)
    department = Column(String(50), nullable=False)
    year = Column(Integer, nullable=False)
    subject_name = Column(String(100), nullable=False)
    day_of_week = Column(Integer, nullable=False)
    start_time = Column(String(5), nullable=False)
    end_time = Column(String(5), nullable=False)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationship with cascading deletes
    attendance_records = relationship("Attendance", back_populates="schedule", cascade="all, delete", passive_deletes=True)

    def to_dict(self):
        return {
            'id': self.id, 
            'subject_name': self.subject_name, 
            'day_of_week': self.day_of_week,
            'start_time': self.start_time, 
            'end_time': self.end_time
        }

class Notice(Base):
    __tablename__ = 'notices'
    id = Column(Integer, primary_key=True)
    department = Column(String(50), nullable=False)
    year = Column(Integer, nullable=True)
    message = Column(Text, nullable=False)
    timestamp = Column(DateTime, default=datetime.datetime.utcnow)
    # Added ondelete="CASCADE" to the foreign key
    author_id = Column(Integer, ForeignKey('users.id', ondelete="CASCADE"))
    author = relationship("User", back_populates="notices")

    def to_dict(self):
        return {
            'id': self.id, 
            'message': self.message, 
            'timestamp': self.timestamp.isoformat(),
            'author': self.author.to_dict()
        }

class Attendance(Base):
    __tablename__ = 'attendance'
    id = Column(Integer, primary_key=True)
    # Added ondelete="CASCADE" to foreign keys
    user_id = Column(Integer, ForeignKey('users.id', ondelete="CASCADE"))
    schedule_id = Column(Integer, ForeignKey('schedules.id', ondelete="CASCADE"))
    timestamp = Column(DateTime, nullable=False)
    status = Column(String(10), default='present')

    # Added back-populating relationships
    user = relationship("User", back_populates="attendance_records")
    schedule = relationship("Schedule", back_populates="attendance_records")

    def to_dict(self):
        return {
            'id': self.id,
            'user_id': self.user_id,
            'schedule_id': self.schedule_id,
            'timestamp': self.timestamp.isoformat(),
            'status': self.status
        }

def create_db():
    Base.metadata.create_all(engine)
    print("Database tables created successfully.")

if __name__ == '__main__':
    create_db()

# cleanup_scheduler.py
import datetime
from sqlalchemy import or_
from database import Session, User

def delete_graduated_students():
    """
    Checks for students who have completed their college journey and deletes their records.
    - 4-year journey for all faculties except BAR.
    - 5-year journey for BAR faculty.
    Deletion occurs if the current year is past their graduation year.
    """
    db_session = Session()
    current_year = datetime.datetime.now().year
    print(f"[{datetime.datetime.now()}] Running cleanup job for year {current_year}...")
    
    deleted_count = 0
    try:
        # Fetch all users who are students or CRs
        students_to_check = db_session.query(User).filter(
            or_(User.role == 'student', User.role == 'cr')
        ).all()

        for student in students_to_check:
            # Ensure the student record has an admission year and department
            if not student.year or not student.department:
                continue

            # Determine the course duration based on faculty
            duration = 5 if student.department.upper() == 'BAR' else 4
            
            # The year the student is expected to have graduated
            expiry_year = student.year + duration

            # If the current year is past the student's expiry year, delete them
            if current_year > expiry_year:
                print(f"DELETING -> User: {student.name} (ID: {student.id}), Admission: {student.year}, Dept: {student.department}. Expiry Year was {expiry_year}.")
                db_session.delete(student)
                deleted_count += 1
        
        if deleted_count > 0:
            db_session.commit()
            print(f"✅ Successfully deleted {deleted_count} graduated student(s).")
        else:
            print("✅ No students found for deletion at this time.")

    except Exception as e:
        db_session.rollback()
        print(f"❌ An error occurred during cleanup: {e}")
    finally:
        db_session.close()

if __name__ == '__main__':
    delete_graduated_students()

#attendance_taker.py
import cv2
import time
import datetime
import sqlite3
import json
from deepface import DeepFace
from recognition_core import FaceRecognitionCore

LOCAL_DB_PATH = 'local_database.db'
RECOGNITION_INTERVAL = 3 # seconds

def setup_local_db():
    conn = sqlite3.connect(LOCAL_DB_PATH)
    cursor = conn.cursor()
    cursor.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, embeddings TEXT)')
    cursor.execute('CREATE TABLE IF NOT EXISTS schedules (id INTEGER PRIMARY KEY, subject_name TEXT, day_of_week INTEGER, start_time TEXT, end_time TEXT)')
    cursor.execute('CREATE TABLE IF NOT EXISTS attendance (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, schedule_id INTEGER, timestamp TEXT, synced INTEGER DEFAULT 0)')
    conn.commit()
    conn.close()

def get_data_from_local_db(query, params=()):
    conn = sqlite3.connect(LOCAL_DB_PATH)
    cursor = conn.cursor()
    cursor.execute(query, params)
    result = cursor.fetchall()
    conn.close()
    return result

def get_current_schedule():
    now = datetime.datetime.now()
    query = "SELECT id, end_time FROM schedules WHERE day_of_week = ? AND start_time <= ? AND end_time >= ?"
    schedule = get_data_from_local_db(query, (now.weekday(), now.strftime("%H:%M"), now.strftime("%H:%M")))
    return schedule[0] if schedule else None

def mark_local_attendance(user_id, schedule_id):
    conn = sqlite3.connect(LOCAL_DB_PATH)
    cursor = conn.cursor()
    cursor.execute("INSERT INTO attendance (user_id, schedule_id, timestamp) VALUES (?, ?, ?)",
                   (user_id, schedule_id, datetime.datetime.now().isoformat()))
    conn.commit()
    conn.close()
    print(f"✅ Attendance marked for user ID {user_id}")

def run_attendance_system():
    setup_local_db()
    
    recognizer = FaceRecognitionCore()
    user_rows = get_data_from_local_db("SELECT id, name, embeddings FROM users")
    users = [(row[0], row[1], json.loads(row[2])) for row in user_rows]
    recognizer.load_known_faces(users)

    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("❌ Error: Cannot open camera.")
        return
        
    print("🚀 Automated attendance system is running...")
    
    current_class_session = None
    students_marked_this_session = set()

    while True:
        schedule_info = get_current_schedule()

        if schedule_info:
            schedule_id, end_time_str = schedule_info
            
            if schedule_id != current_class_session:
                current_class_session = schedule_id
                students_marked_this_session.clear()
                print(f"🔔 New class session started: ID {schedule_id}. Scanning until {end_time_str}.")

            ret, frame = cap.read()
            if not ret: 
                print("⚠️ Warning: Failed to capture frame from camera.")
                time.sleep(1)
                continue

            try:
                # Use a more specific model and backend for consistency
                results = DeepFace.represent(img_path=frame, model_name='FaceNet', detector_backend='mtcnn', enforce_detection=False)
                for face_data in results:
                    # 'embedding' is the key for the vector
                    embedding = face_data.get('embedding')
                    if not embedding:
                        continue
                        
                    user_id, user_name = recognizer.find_matching_face(embedding)
                    
                    if user_id and user_id not in students_marked_this_session:
                        mark_local_attendance(user_id, schedule_id)
                        students_marked_this_session.add(user_id)
            except Exception as e:
                # Log the error instead of passing silently
                print(f"❗️ Error during face recognition process: {e}")
        
        else:
            if current_class_session is not None:
                print("🔕 Class session ended. Pausing until next scheduled class.")
                current_class_session = None
            time.sleep(10) # Sleep longer when no class is active
            continue
            
        time.sleep(RECOGNITION_INTERVAL)

    cap.release()
    cv2.destroyAllWindows()

if __name__ == '__main__':
    run_attendance_system()

# recognition_core.py
import numpy as np
from scipy.spatial.distance import cosine

class FaceRecognitionCore:
    def __init__(self, threshold=0.40):
        self.threshold = threshold
        self.known_face_embeddings = []
        self.known_face_ids = []
        self.known_face_names = []

    def load_known_faces(self, users):
        for user_id, name, embeddings in users:
            for emb in embeddings:
                self.known_face_embeddings.append(np.array(emb))
                self.known_face_ids.append(user_id)
                self.known_face_names.append(name)
        print(f"Loaded embeddings for {len(set(self.known_face_ids))} students.")

    def find_matching_face(self, face_embedding):
        if not self.known_face_embeddings: return None, None
        distances = [cosine(face_embedding, emb) for emb in self.known_face_embeddings]
        min_dist_idx = np.argmin(distances)
        if distances[min_dist_idx] <= self.threshold:
            return self.known_face_ids[min_dist_idx], self.known_face_names[min_dist_idx]
        return None, None
# sync_client.py
import requests
import sqlite3
import json
import time
import datetime

CENTRAL_SERVER_URL = "http://127.0.0.1:5000"
LOCAL_DB_PATH = 'local_database.db'
CONFIG_FILE = 'sync_config.json'
SYNC_INTERVAL = 900 # 15 minutes

def get_last_sync_time():
    try:
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f).get('last_sync_time')
    except (FileNotFoundError, json.JSONDecodeError):
        return None

def set_last_sync_time(sync_time):
    with open(CONFIG_FILE, 'w') as f:
        json.dump({'last_sync_time': sync_time}, f)

def sync_data():
    print(f"[{datetime.datetime.now()}] Starting sync process...")
    conn = sqlite3.connect(LOCAL_DB_PATH)
    cursor = conn.cursor()
    
    # --- PUSH local attendance records to the central server ---
    cursor.execute("SELECT id, user_id, schedule_id, timestamp FROM attendance WHERE synced = 0")
    records_to_push = cursor.fetchall()
    if records_to_push:
        payload = {'records': [{'id': r[0], 'user_id': r[1], 'schedule_id': r[2], 'timestamp': r[3]} for r in records_to_push]}
        try:
            response = requests.post(f"{CENTRAL_SERVER_URL}/api/sync/attendance", json=payload, timeout=15)
            if response.status_code == 200:
                print(f"Successfully pushed {len(records_to_push)} attendance records.")
                ids_to_update = tuple(r[0] for r in records_to_push)
                placeholders = ', '.join('?' for _ in ids_to_update)
                query = f"UPDATE attendance SET synced = 1 WHERE id IN ({placeholders})"
                cursor.execute(query, ids_to_update)
                conn.commit()
            else:
                print(f"Error pushing attendance data: {response.status_code} - {response.text}")
        except requests.exceptions.RequestException as e:
            print(f"Network error while pushing attendance: {e}")

    # --- PULL updates (users, schedules) from the central server ---
    params = {'last_sync_time': get_last_sync_time()}
    try:
        response = requests.get(f"{CENTRAL_SERVER_URL}/api/sync/get_updates", params=params, timeout=15)
        if response.status_code == 200:
            data = response.json()
            updates = data.get('updates', {})
            
            # Update local users table
            users_to_update = updates.get('users', [])
            if users_to_update:
                for user in users_to_update:
                    cursor.execute("INSERT OR REPLACE INTO users (id, name, embeddings) VALUES (?, ?, ?)", 
                                   (user['id'], user['name'], json.dumps(user.get('embeddings', []))))
                print(f"Synced {len(users_to_update)} user records.")
            
            # Update local schedules table
            schedules_to_update = updates.get('schedules', [])
            if schedules_to_update:
                for s in schedules_to_update:
                    cursor.execute("INSERT OR REPLACE INTO schedules (id, subject_name, day_of_week, start_time, end_time) VALUES (?, ?, ?, ?, ?)", 
                                   (s['id'], s['subject_name'], s['day_of_week'], s['start_time'], s['end_time']))
                print(f"Synced {len(schedules_to_update)} schedule records.")

            conn.commit()
            set_last_sync_time(data.get('server_time'))
            print("Sync successful. Updated last sync time.")
        else:
            print(f"Error pulling updates: {response.status_code} - {response.text}")
    except requests.exceptions.RequestException as e:
        print(f"Network error while pulling updates: {e}")
    except Exception as e:
        print(f"An unexpected error occurred during sync: {e}")
    finally:
        conn.close()

if __name__ == '__main__':
    while True:
        sync_data()
        print(f"Next sync in {SYNC_INTERVAL} seconds.")
        time.sleep(SYNC_INTERVAL)
# face_capture.py

from deepface import DeepFace
import numpy as np
import cv2

def get_embedding_from_image_bytes(image_bytes):
    try:
        nparr = np.frombuffer(image_bytes, np.uint8)
        img_np = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        embedding_objs = DeepFace.represent(
            img_path=img_np,
            model_name='FaceNet',
            detector_backend='mtcnn',
            enforce_detection=True
        )
        if embedding_objs and 'embedding' in embedding_objs[0]:
            return embedding_objs[0]['embedding']
    except Exception as e:
        print(f"Could not process image: {e}")
    return None
